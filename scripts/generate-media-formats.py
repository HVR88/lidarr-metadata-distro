#!/usr/bin/env python3
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, Iterable, List, Tuple


ROOT = Path(__file__).resolve().parents[1]
SOURCE_PATH = ROOT / "data" / "media_formats_meta.json"
PY_OUT = ROOT / "overlay" / "bridge" / "lidarrmetadata" / "media_formats_meta.py"
CS_OUT = ROOT / "lm-bridge-plugin" / "plugin" / "Metadata" / "MetadataSourceOverride" / "MediaFormats.generated.cs"
DOCS_OUT = ROOT / "docs" / "Media-Formats.md"

_SMALL_TITLE_WORDS = {
    "a",
    "an",
    "and",
    "for",
    "in",
    "of",
    "on",
    "or",
    "the",
    "to",
    "vs",
}


def _load_json_objects(text: str) -> List[dict]:
    parts = [part.strip() for part in text.strip().split("\n\n") if part.strip()]
    if len(parts) == 1:
        value = json.loads(parts[0])
        if isinstance(value, list):
            return value
        if isinstance(value, dict):
            return [value]
    return [json.loads(part) for part in parts]


def _validate(data: List[dict]) -> Dict[str, List[dict]]:
    if len(data) != 2:
        raise SystemExit(f"Expected 2 JSON objects (digital + analog), got {len(data)}")
    by_type: Dict[str, List[dict]] = {}
    for obj in data:
        type_name = obj.get("type")
        if type_name not in {"digital", "analog"}:
            raise SystemExit(f"Invalid type: {type_name!r}")
        meta_formats = obj.get("meta_formats")
        if not isinstance(meta_formats, list) or not meta_formats:
            raise SystemExit(f"Missing meta_formats for type: {type_name}")
        by_type[type_name] = meta_formats

    if set(by_type) != {"digital", "analog"}:
        raise SystemExit(f"Missing digital or analog types: {set(by_type)}")

    for type_name, meta in by_type.items():
        seen_meta = set()
        seen_formats = set()
        for group in meta:
            name = group.get("name")
            if not name or not isinstance(name, str):
                raise SystemExit(f"Missing meta name in {type_name}")
            if name in seen_meta:
                raise SystemExit(f"Duplicate meta name {name!r} in {type_name}")
            seen_meta.add(name)

            formats = group.get("formats")
            if not isinstance(formats, list) or not formats:
                raise SystemExit(f"Missing formats for meta {name!r} in {type_name}")
            for fmt in formats:
                if not fmt or not isinstance(fmt, str):
                    raise SystemExit(f"Invalid format in {name!r} ({type_name})")
                if fmt in seen_formats:
                    raise SystemExit(f"Duplicate format {fmt!r} in {type_name}")
                seen_formats.add(fmt)

    all_formats = set()
    for meta in by_type.values():
        for group in meta:
            for fmt in group["formats"]:
                if fmt in all_formats:
                    raise SystemExit(f"Format {fmt!r} appears in multiple types")
                all_formats.add(fmt)

    return by_type


def _build_alias_map(by_type: Dict[str, List[dict]]) -> Dict[str, List[str]]:
    alias_map: Dict[str, List[str]] = {}
    for type_name, meta in by_type.items():
        all_formats: List[str] = []
        for group in meta:
            formats = [fmt.lower() for fmt in group["formats"]]
            alias_map[group["name"].lower()] = formats
            all_formats.extend(formats)
        alias_map[type_name] = all_formats
    return alias_map


def _flatten_priority(by_type: Dict[str, List[dict]], type_order: Iterable[str]) -> List[str]:
    ordered: List[str] = []
    for type_name in type_order:
        for group in by_type[type_name]:
            ordered.extend([fmt.lower() for fmt in group["formats"]])
    return ordered


def _emit_python(by_type: Dict[str, List[dict]]) -> None:
    alias_map = _build_alias_map(by_type)
    priority_digital_first = _flatten_priority(by_type, ["digital", "analog"])
    priority_analog_first = _flatten_priority(by_type, ["analog", "digital"])

    def py_repr(value: object) -> str:
        return json.dumps(value, ensure_ascii=False, indent=2)

    content = [
        "# Generated by scripts/generate-media-formats.py. Do not edit by hand.",
        f"# Source: {SOURCE_PATH.as_posix()}",
        "",
        f"MEDIA_FORMATS_META = {py_repr(by_type)}",
        f"META_ORDER = {py_repr({k: [g['name'] for g in v] for k, v in by_type.items()})}",
        f"ALIAS_MAP = {py_repr(alias_map)}",
        f"PRIORITY_DIGITAL_FIRST = {py_repr(priority_digital_first)}",
        f"PRIORITY_ANALOG_FIRST = {py_repr(priority_analog_first)}",
        "",
    ]
    PY_OUT.write_text("\n".join(content), encoding="utf-8")


def _emit_csharp(by_type: Dict[str, List[dict]]) -> None:
    meta_names: List[str] = []
    format_names: List[str] = []
    for type_name in ("digital", "analog"):
        for group in by_type[type_name]:
            meta_names.append(group["name"])
            format_names.extend(group["formats"])

    def to_csharp_array(items: Iterable[str], indent: int = 12) -> str:
        pad = " " * indent
        lines = [f'{pad}"{item.replace("\"", "\\\"")}",' for item in items]
        return "\n".join(lines)

    meta_array = to_csharp_array(meta_names)
    format_array = to_csharp_array(format_names)
    format_lower_array = to_csharp_array([f.lower() for f in format_names])

    content = f"""// Generated by scripts/generate-media-formats.py. Do not edit by hand.
// Source: {SOURCE_PATH.as_posix()}

using System;
using System.Collections.Generic;

namespace LMBridgePlugin.Metadata.MetadataSourceOverride
{{
    internal static class MediaFormats
    {{
        internal static readonly string[] MetaFormatNames = new[]
        {{
{meta_array}
        }};

        internal static readonly HashSet<string> MetaFormatNamesSet = new HashSet<string>(MetaFormatNames, StringComparer.OrdinalIgnoreCase);

        internal static readonly string[] FormatNames = new[]
        {{
{format_array}
        }};

        internal static readonly string[] FormatNamesLower = new[]
        {{
{format_lower_array}
        }};
    }}
}}
"""
    CS_OUT.write_text(content, encoding="utf-8")


def _normalize_heading_title(title: str) -> str:
    words = title.split(" ")
    normalized: List[str] = []
    idx = 0
    while idx < len(words):
        word = words[idx]
        if not word.isalpha():
            normalized.append(word)
            idx += 1
            continue
        lower = word.lower()
        next_word = words[idx + 1] if idx + 1 < len(words) else None
        if lower == "hi" and next_word and next_word.isalpha() and next_word.lower() == "res":
            normalized.append("Hi-Res")
            idx += 2
            continue
        if lower == "cd":
            normalized.append("CD")
            idx += 1
            continue
        if idx > 0 and lower in _SMALL_TITLE_WORDS:
            normalized.append(lower)
        else:
            normalized.append(word)
        idx += 1
    return " ".join(normalized)


def _normalize_docs_headings() -> None:
    if not DOCS_OUT.exists():
        return
    lines = DOCS_OUT.read_text(encoding="utf-8").splitlines()
    changed = False
    for idx, line in enumerate(lines):
        if not line.startswith("### ") or " (" not in line or not line.rstrip().endswith(")"):
            continue
        title, rest = line[4:].split(" (", 1)
        normalized = _normalize_heading_title(title)
        if normalized != title:
            lines[idx] = f"### {normalized} ({rest}"
            changed = True
    if changed:
        DOCS_OUT.write_text("\n".join(lines) + "\n", encoding="utf-8")


def main() -> None:
    if not SOURCE_PATH.exists():
        raise SystemExit(f"Missing source file: {SOURCE_PATH}")
    data = _load_json_objects(SOURCE_PATH.read_text(encoding="utf-8"))
    by_type = _validate(data)
    _emit_python(by_type)
    _emit_csharp(by_type)
    _normalize_docs_headings()
    print(f"Wrote {PY_OUT}")
    print(f"Wrote {CS_OUT}")


if __name__ == "__main__":
    main()
