name: Publish Version

on:
  workflow_dispatch:
    inputs:
      platforms:
        description: "Target platforms"
        required: true
        default: "linux/amd64"
      publish_container:
        description: "Publish Docker container (build/push + deploy sync)"
        required: true
        default: "true"
      version:
        description: "Override version (x.y.z or x.y.z.bb)"
        required: false
        default: ""

permissions:
  contents: write

env:
  IMAGE_NAME: espressomatic/limbo
  DEPLOY_REPO: ${{ github.repository_owner }}/Limbo

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Validate publish targets
        run: |
          if [[ "${{ inputs.publish_container }}" != "true" ]]; then
            echo "publish_container must be true." >&2
            exit 1
          fi

      - name: Generate media format mappings
        run: |
          python3 scripts/generate-media-formats.py

      - name: Bump patch + sync version files
        id: bump
        run: |
          set -e
          if [ ! -f VERSION ]; then
            echo "VERSION file not found." >&2
            exit 1
          fi

          export INPUT_VERSION="${{ inputs.version }}"
          PY_OUTPUT=$(python3 - <<'PY'
          import re
          import os
          from pathlib import Path

          version_path = Path("VERSION")
          version_input = os.environ.get("INPUT_VERSION", "").strip()

          def _clean(raw: str) -> str:
              raw = "".join(raw.split())
              if raw.startswith("v"):
                  raw = raw[1:]
              return raw

          def _release_version(version: str) -> str:
              m = re.fullmatch(r"(\d+\.\d+\.\d+)\.(\d{1,3})", version)
              if m and int(m.group(2)) == 0:
                  return m.group(1)
              return version

          def _docker_version(version: str) -> str:
              m = re.fullmatch(r"(\d+\.\d+\.\d+)\.(\d{1,3})", version)
              if m:
                  return m.group(1)
              m = re.fullmatch(r"(\d+\.\d+\.\d+)", version)
              if m:
                  return m.group(1)
              raise SystemExit(f"Invalid version for Docker tag: {version!r}")

          if version_input:
              version_input = _clean(version_input)
              if not re.fullmatch(r"\d+\.\d+\.\d+(?:\.\d{1,3})?", version_input):
                  raise SystemExit(f"Invalid version override (use x.y.z or x.y.z.bb): {version_input!r}")
              new_version = version_input
          else:
              version = _clean(version_path.read_text())
              m3 = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)", version)
              m4 = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)\.(\d{1,3})", version)
              if not m3 and not m4:
                  raise SystemExit(f"VERSION format invalid: {version!r}")
              if m3:
                  major, minor, patch = map(int, m3.groups())
                  patch += 1
                  new_version = f"{major}.{minor}.{patch}"
              else:
                  major, minor, patch, _build = map(int, m4.groups())
                  patch += 1
                  new_version = f"{major}.{minor}.{patch}.00"

          version_path.write_text(new_version + "\n")
          Path("deploy/VERSION").write_text(new_version + "\n")

          readme_path = Path("deploy/README.md")
          if readme_path.exists():
            readme_text = readme_path.read_text()
            readme_text, count = re.subn(r"Deploy version: `[^`]+`",
                                         f"Deploy version: `{new_version}`", readme_text, count=1)
            if count == 1:
              readme_path.write_text(readme_text)

          release_version = _release_version(new_version)
          docker_version = _docker_version(new_version)
          print(new_version)
          print(release_version)
          print(docker_version)
          PY
          )

          NEW_VERSION=$(echo "$PY_OUTPUT" | sed -n '1p')
          RELEASE_VERSION=$(echo "$PY_OUTPUT" | sed -n '2p')
          DOCKER_VERSION=$(echo "$PY_OUTPUT" | sed -n '3p')

          echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          echo "release_version=$RELEASE_VERSION" >> "$GITHUB_OUTPUT"
          echo "docker_version=$DOCKER_VERSION" >> "$GITHUB_OUTPUT"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add VERSION deploy/VERSION deploy/README.md \
            overlay/bridge/lidarrmetadata/media_formats_meta.py
          if git diff --cached --quiet; then
            echo "No version change to commit."
          else
            NEW_VERSION="${{ steps.bump.outputs.new_version }}"
            git commit -m "Publish version ${NEW_VERSION}"
            git push
          fi

      - name: Tag release
        run: |
          VERSION="${{ steps.bump.outputs.release_version }}"
          TAG="v${VERSION}"
          git fetch --tags
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists."
            exit 0
          fi
          git tag -a "$TAG" -m "Version $VERSION"
          git push origin "$TAG"

      - name: Set up QEMU
        if: ${{ inputs.publish_container == 'true' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ inputs.publish_container == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: ${{ inputs.publish_container == 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_LIMBO }}

      - name: Compute Docker tags
        if: ${{ inputs.publish_container == 'true' }}
        id: docker-tags
        shell: bash
        run: |
          version="${{ steps.bump.outputs.docker_version }}"
          if [[ "$version" =~ ^([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            docker_tag="${BASH_REMATCH[1]}"
          else
            echo "Invalid version for Docker Hub tag: $version" >&2
            exit 1
          fi
          echo "docker_tag=$docker_tag" >> "$GITHUB_OUTPUT"

      - name: Build and push image
        if: ${{ inputs.publish_container == 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          build-args: |
            APP_VERSION=${{ steps.docker-tags.outputs.docker_tag }}
          platforms: ${{ inputs.platforms }}
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ steps.docker-tags.outputs.docker_tag }}
            ${{ env.IMAGE_NAME }}:latest
          labels: |
            org.opencontainers.image.title=Limbo
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.version=${{ steps.docker-tags.outputs.docker_tag }}

      - name: Update Docker Hub description
        if: ${{ inputs.publish_container == 'true' }}
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN_LIMBO }}
          repository: espressomatic/limbo
          readme-filepath: DOCKERHUB_DESCRIPTION.md

      - name: Checkout deploy repo
        if: ${{ inputs.publish_container == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ env.DEPLOY_REPO }}
          token: ${{ secrets.GH_DEPLOY_LIMBO }}
          path: deploy-repo

      - name: Sync deploy folder
        if: ${{ inputs.publish_container == 'true' }}
        run: |
          chmod +x scripts/export-deploy.sh
          DEPLOY_REPO=deploy-repo DEPLOY_DELETE=1 scripts/export-deploy.sh

      - name: Commit and push deploy repo
        if: ${{ inputs.publish_container == 'true' }}
        run: |
          if [[ -z "$(git -C deploy-repo status --porcelain)" ]]; then
            echo "No changes to deploy repo."
            exit 0
          fi
          git -C deploy-repo config user.name "github-actions[bot]"
          git -C deploy-repo config user.email "github-actions[bot]@users.noreply.github.com"
          git -C deploy-repo add .
          sync_sha="$(git rev-parse HEAD)"
          git -C deploy-repo commit -m "Sync deploy from ${GITHUB_REPOSITORY}@${sync_sha}"
          git -C deploy-repo push

      - name: Create deploy zip release
        if: ${{ inputs.publish_container == 'true' }}
        env:
          RELEASE_VERSION: ${{ steps.bump.outputs.release_version }}
        run: |
          set -euo pipefail
          tag="v${RELEASE_VERSION}"
          zip_name="limbo-deploy-${RELEASE_VERSION}.zip"
          (cd deploy-repo && zip -r "/tmp/${zip_name}" . -x ".git/*")
          if gh release view "$tag" -R "${DEPLOY_REPO}" >/dev/null 2>&1; then
            gh release upload "$tag" "/tmp/${zip_name}" -R "${DEPLOY_REPO}" --clobber
          else
            gh release create "$tag" "/tmp/${zip_name}" -R "${DEPLOY_REPO}" \
              --title "Limbo Deploy ${RELEASE_VERSION}" \
              --notes "Deploy bundle for Limbo ${RELEASE_VERSION}."
          fi
